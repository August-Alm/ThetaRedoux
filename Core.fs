module Theta.Core

let inline private index (dep : int) (l : int) =
  if l < 0 then dep + l else l

let inline private level (len : int) (i : int) =
  len - i

type Term =
  /// x -- variable (with de Bruijn index)
  | Var of string * int
  /// λx.t -- lambda abstraction
  | Lam of string * Term
  /// (t u) -- application
  | App of Term * Term
  /// θx.t -- theta abstraction
  | Tht of string * Term
  /// [t u] -- annotation
  | Ann of Term * Term
  /// μx.t -- fixpoint binder
  | Fix of string * Term

type Hoas =
  | HVar of string * int
  | HLam of string * (Hoas -> Hoas)
  | HApp of Hoas * Hoas
  | HTht of string * (Hoas -> Hoas)
  | HAnn of Hoas * Hoas
  | HFix of string * (Hoas -> Hoas)
  
let rec hoas (env : Hoas list) (t : Term) =
  match t with
  | Var (x, i) ->
    match List.tryItem (int i) env with
    | Some v -> v
    | None -> HVar (x, level env.Length i) 
  | Lam (x, t) -> HLam (x, fun u -> hoas (u :: env) t)
  | App (t, u) -> HApp (hoas env t, hoas env u)
  | Tht (x, t) ->
    HTht (x, (fun u -> hoas (u :: env) t))
  | Ann (t, u) -> HAnn (hoas env t, hoas env u)
  | Fix (x, t) -> HFix (x, fun u -> hoas (u :: env) t)

let private fresh (xs : string list) (x : string) =
  let rec go x = if List.contains x xs then go (x + "'") else x
  let x = go x
  let xs = x :: xs
  x, HVar (x, -(List.length xs)), xs  

let rec term (xs : string list) (t : Hoas) =
  match t with
  | HVar (x, l) -> Var (x, index (List.length xs) l)
  | HLam (x, t) -> let x, xv, xs = fresh xs x in Lam (x, term xs (t xv))
  | HApp (t, u) -> App (term xs t, term xs u)
  | HTht (x, t) -> let x, xv, xs = fresh xs x in Tht (x, term xs (t xv))
  | HAnn (t, u) -> Ann (term xs t, term xs u)
  | HFix (x, t) -> let x, xv, xs = fresh xs x in Fix (x, term xs (t xv))

let quote = term []

// Alpha-eta equivalence generated by eta rules: λx.(t x) ≃ t ≃ θx.[x t]
// For fixpoints, we use an algorithm that avoids infinite unrolling;
// it gives no false positives but may (?) give false negatives.
let rec eq dep t u =
  match t, u with
  | HVar (_, i), HVar (_, j) -> i = j
  | HLam (x, t), HLam (_, u) ->
    eq (dep + 1) (t (HVar (x, dep))) (u (HVar (x, dep)))
  | HLam (x, t), u ->
    eq (dep + 1) (t (HVar (x, dep))) (HApp (u, HVar (x, dep)))
  | t, HLam (y, u) ->
    eq (dep + 1) (HApp (t, HVar (y, dep))) (u (HVar (y, dep)))
  | HApp (f, a), HApp (g, b) ->
    eq dep f g && eq dep a b
  | HTht (x, t), HTht (_, u) ->
    eq (dep + 1) (t (HVar (x, dep))) (u (HVar (x, dep)))
  | HTht (x, t), u ->
    eq (dep + 1) (t (HVar (x, dep))) (HAnn (HVar (x, dep), u))
  | t, HTht (y, u) ->
    eq (dep + 1) (HAnn (HVar (y, dep), t)) (u (HVar (y, dep)))
  | HAnn (t, a), HAnn (u, b) ->
    eq dep t u && eq dep a b
  | HFix (x, t), HFix (_, u) ->
    eq (dep + 1) (t (HVar (x, dep))) (u (HVar (x, dep)))
  | HFix (_, t), u -> eq dep (t u) u
  | t, HFix (_, b) -> eq dep t (b u)
  | _ -> false 

// Strong normalization.
let rec norm trm =
  match trm with
  | HVar _ -> trm
  | HLam (x, t) -> HLam (x, fun x -> norm (t x))
  | HApp (t, u) ->
    match norm t with
    // (λx.t u) -> t{x = u}
    | HLam (_, t) -> norm (t u)
    // (θx.t u) -> θx.(t [x u])
    | HTht (x, t) -> norm (HTht (x, fun x -> HApp (t x, HAnn (x, u))))
    // ([t v] u) -> [(t v) (u v)]
    | HAnn (t, v) -> norm (HAnn (HApp (t, v), HApp (u, v)))
    // (μx.t u) -> (t{x = μx.t} u)
    | HFix (_, t) as fix -> norm (HApp (t fix, u)) 
    | t -> HApp (t, norm u)
  | HTht (x, t) -> HTht (x, fun x -> norm (t x))
  | HAnn (HFix (x, t), u) ->
    // [μx.t u] -> μx.[t{x = [x u]} u]
    HFix (x, fun x -> norm (HAnn (t (HAnn (x, u)), u)))
  | HAnn (t, u) ->
    match norm u with
    // [t θx.u] -> u{x = t}
    | HTht (_, u) -> norm (u t)
    // [t λx.u] -> λx.[(t x) u]
    | HLam (x, u) -> norm (HLam (x, fun x -> HAnn (HApp (t, x), u x)))
    | u ->
      match norm t with
      // [[t a] b] when a ≃ b -> t
      | HAnn (t, v) when eq 0 u v -> t
      | t -> HAnn (t, u)
  | HFix (x, t) -> HFix (x, fun x -> norm (t x))


[<RequireQualifiedAccess>]
module Term =

  /// Strong normal form.
  let normalize = quote << norm << (hoas [])

  /// Alpha-eta equality.
  let equal t u = eq 0 (hoas [] t) (hoas [] u)

  /// Pretty-print.
  let rec show (trm : Term) =
    match trm with
    | Var (x, _) -> x
    | Lam (x, t) -> $"λ{x}.{show t}"
    | App (t, u) -> $"({show t} {show u})"
    | Tht (x, t) -> $"θ{x}.{show t}"
    | Ann (t, u) -> $"[{show t} {show u}]"
    | Fix (x, t) -> $"μ{x}.{show t}"